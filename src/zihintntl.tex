\chapter{``Zihintntl'' Non-Temporal Locality Hints, Version 0.1}
\label{chap:zihintpause}

The NTL instructions are HINTs that indicate that the immediately subsequent
memory-access instruction exhibits poor temporal locality of reference.
The NTL instructions do not change architectural state, nor do they alter the
architecturally visible effects of the subsequent memory-access instruction.
Three variants are provided:

The NTL.L1 instruction indicates that the subsequent memory-access instruction
does not exhibit temporal locality within the capacity of the innermost level
of cache in the memory hierarchy (e.g., an L1 cache).
NTL.L1 is encoded as \mbox{ADD {\em x0, x0, x1}}.

The NTL.L2 instruction indicates that the subsequent memory-access instruction
does not exhibit temporal locality within the capacity of the next-innermost
level of cache in the memory hierarchy (e.g., an L2 cache).
NTL.L2 is encoded as \mbox{ADD {\em x0, x0, x2}}.

The NTL.LLC instruction indicates that the subsequent memory-access
instruction does not exhibit temporal locality within the capacity of the last
level of cache in the memory hierarchy.
NTL.LLC is encoded as \mbox{ADD {\em x0, x0, x3}}.

\begin{commentary}
The NTL instructions can be used to avoid cache pollution when streaming data
or traversing large data structures, or to reduce latency in producer-consumer
interactions.

A microarchitecture might use the NTL instructions to inform the cache
replacement policy, or to decide which cache to allocate into, or to avoid
cache allocation altogether.
For example, NTL.L1 might indicate that an implementation should not allocate
a line in an L1 cache, but should allocate in L2.
In another implementation, NTL.L1 might allocate the line in L1, but in
the least-recently used state.
Many implementations will treat NTL.L2 analogously, but with respect to both
L1 and L2 caches.

NTL.LLC will typically inform implementations not to allocate anywhere in the
cache hierarchy.
Programmers should use NTL.LLC for accesses that have no exploitable temporal
locality.

Like any HINTs, these instructions may be freely ignored.
Hence, although they are described in terms of cache-based memory hierarchies,
they do not mandate the provision of caches.

Some implementations might respect these HINTs for some memory accesses but
not others: e.g., implementations that implement LR/SC by acquiring a
cache line in the exclusive state in L1 might ignore NTL instructions
on LR and SC, but might respect NTL instructions for
AMOs and regular loads and stores.
\end{commentary}

If the C extension is provided, compressed variants of these HINTs are also
provided:
C.NTL.L1 is encoded as \mbox{C.ADD {\em x0, x1}};
C.NTL.L2 is encoded as \mbox{C.ADD {\em x0, x2}};
and C.NTL.LLC is encoded as \mbox{C.ADD {\em x0, x3}}.


The NTL instructions affect all memory-access instructions, unless otherwise
specified.

\begin{commentary}
As of this writing, there are no exclusions to this rule, and so
the NTL instructions affect all memory-access instructions
defined in the base ISAs and the A, F, D, Q, C, and V standard extensions,
as well as those defined within the hypervisor extension in Volume II.

We also expect that the NTL instructions will affect some cache-maintenance
operations.
For example, NTL.L2 followed by a cache-line-zero instruction might indicate
that the line should be allocated in L3 and zeroed, but not allocated in
L1 or L2.
\end{commentary}

Software is discouraged from following an NTL instruction with an
instruction that does not explicitly access memory.
Nonadherence to this recommendation might reduce performance but
otherwise has no architecturally visible effect.

In the event that a trap is taken on the instruction following an NTL,
implementations are discouraged from applying the NTL to the first instruction
in the trap handler.
Instead, implementations are recommended to ignore the HINT in this case.

\begin{commentary}
If an interrupt occurs between the execution of an NTL instruction and its
subsequent memory-access instruction, execution will normally resume at the
memory-access instruction.
That the NTL instruction is not reexecuted does not change the semantics of
the program.

Some implementations might prefer not to process the NTL instruction until the
subsequent memory-access instruction is seen (e.g., so that the NTL can be
fused with the memory access it modifies).
Such implementations might preferentially take the interrupt before the NTL,
rather than between the NTL and the memory access.
\end{commentary}

\begin{commentary}
Since the NTL instructions are encoded as ADDs, they can be used within LR/SC
loops without voiding the forward-progress guarantee.
But, since using other loads and stores within an LR/SC loop {\em does}
void the forward-progress guarantee, the only reason to use an NTL
within such a loop is to modify the LR or the SC.
\end{commentary}
