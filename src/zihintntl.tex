\chapter{``Zihintntl'' Non-Temporal Locality Hints, Version 0.1}
\label{chap:zihintpause}

The NTL instructions are HINTs that indicate that the explicit memory accesses of the immediately subsequent
instruction (henceforth "target instruction") exhibit poor temporal locality of reference.
The NTL instructions do not change architectural state, nor do they alter the
architecturally visible effects of the target instruction.
Three variants are provided:

The NTL.L1 instruction indicates that the target instruction
does not exhibit temporal locality within the capacity of the innermost level
of cache in the memory hierarchy (e.g., an L1 cache).
NTL.L1 is encoded as \mbox{ADD {\em x0, x0, x2}}.

The NTL.L2 instruction indicates that the target instruction
does not exhibit temporal locality within the capacity of the two innermost
levels of cache in the memory hierarchy.
NTL.L2 is encoded as \mbox{ADD {\em x0, x0, x3}}.

The NTL.L3 instruction indicates that the target instruction
does not exhibit temporal locality within the capacity of the three innermost
levels of cache in the memory hierarchy.
NTL.L3 is encoded as \mbox{ADD {\em x0, x0, x4}}.

The NTL.LLC instruction indicates that the target
instruction does not exhibit temporal locality within the capacity of the last
level of cache in the memory hierarchy.
NTL.LLC is encoded as \mbox{ADD {\em x0, x0, x5}}.

\begin{commentary}
The NTL instructions can be used to avoid cache pollution when streaming data
or traversing large data structures, or to reduce latency in producer-consumer
interactions.

A microarchitecture might use the NTL instructions to inform the cache
replacement policy, or to decide which cache to allocate into, or to avoid
cache allocation altogether.
For example, NTL.L1 might indicate that an implementation should not allocate
a line in an L1 cache, but should allocate in L2.
In another implementation, NTL.L1 might allocate the line in L1, but in
the least-recently used state.
Many implementations will treat NTL.L2 and NTL.L3 analogously, but affecting
all cache levels between L1 and the encoded level.

NTL.LLC will typically inform implementations not to allocate anywhere in the
cache hierarchy.
Programmers should use NTL.LLC for accesses that have no exploitable temporal
locality.

Like any HINTs, these instructions may be freely ignored.
Hence, although they are described in terms of cache-based memory hierarchies,
they do not mandate the provision of caches.

Some implementations might respect these HINTs for some memory accesses but
not others: e.g., implementations that implement LR/SC by acquiring a
cache line in the exclusive state in L1 might ignore NTL instructions
on LR and SC, but might respect NTL instructions for
AMOs and regular loads and stores.
\end{commentary}

If the C extension is provided, compressed variants of these HINTs are also
provided:
C.NTL.L1 is encoded as \mbox{C.ADD {\em x0, x2}};
C.NTL.L2 is encoded as \mbox{C.ADD {\em x0, x3}};
C.NTL.L3 is encoded as \mbox{C.ADD {\em x0, x4}};
and C.NTL.LLC is encoded as \mbox{C.ADD {\em x0, x5}}.

The NTL instructions affect all memory-access instructions, unless otherwise
specified.

\begin{commentary}
As of this writing, there are no exclusions to this rule, and so
the NTL instructions affect all memory-access instructions
defined in the base ISAs and the A, F, D, Q, C, and V standard extensions,
as well as those defined within the hypervisor extension in Volume II.

We also expect that the NTL instructions will affect some cache-maintenance
operations.
For example, NTL.L2 followed by a cache-line-zero instruction might indicate
that the line should be allocated in L3 and zeroed, but not allocated in
L1 or L2.
\end{commentary}

Software is discouraged from following an NTL instruction with an
instruction that does not explicitly access memory.
Nonadherence to this recommendation might reduce performance but
otherwise has no architecturally visible effect.

In the event that a trap is taken on the target instruction,
implementations are discouraged from applying the NTL to the first instruction
in the trap handler.
Instead, implementations are recommended to ignore the HINT in this case.

\begin{commentary}
If an interrupt occurs between the execution of an NTL instruction and its
target instruction, execution will normally resume at the
target instruction.
That the NTL instruction is not reexecuted does not change the semantics of
the program.

Some implementations might prefer not to process the NTL instruction until the
target instruction is seen (e.g., so that the NTL can be
fused with the memory access it modifies).
Such implementations might preferentially take the interrupt before the NTL,
rather than between the NTL and the memory access.
\end{commentary}

\begin{commentary}
Since the NTL instructions are encoded as ADDs, they can be used within LR/SC
loops without voiding the forward-progress guarantee.
But, since using other loads and stores within an LR/SC loop {\em does}
void the forward-progress guarantee, the only reason to use an NTL
within such a loop is to modify the LR or the SC.
\end{commentary}
