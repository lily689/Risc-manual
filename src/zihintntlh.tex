\chapter{``Zihintntlh'' Non-Temporal Locality Hint, Version 1.0}
\label{chap:zihintpause}

The NTLH instruction is a HINT that indicates that the immediately subsequent
memory-access instruction exhibits poor temporal locality of reference.
NTLH does not change architectural state, nor does it alter the architecturally
visible effects of the subsequent memory-access instruction.

\begin{commentary}
NTLH can be used to avoid cache pollution when streaming data or traversing
large data structures, or to reduce latency in producer-consumer interactions.

A microarchitecture might use NTLH to inform the cache replacment policy, or to
decide which cache to allocate into, or to avoid cache allocation altogether.
\end{commentary}

NTLH affects all memory-access instructions defined in the base ISA and
the A, F, D, Q, C, and V standard extensions.

\begin{commentary}
The expectation is that NTLH will also affect memory-access instructions
defined in later standard or custom extensions.
\end{commentary}

NTLH is encoded as ADD {\em x0, x0, x3}.
If the C extension is implemented, a C.NTLH instruction with the same semantics
is also provided and is encoded as C.MV {\em x0, x3}.

\begin{commentary}
In the standard ABIs, the \texttt{x3} register is rarely written, so this
encoding avoids spurious interlocks even on simple implementations.
\end{commentary}

Software is discouraged from following the NTLH instruction with an
instruction that does not explicitly access memory.
Nonadherence to this recommendation might reduce performance but
otherwise has no architecturally visible effect.

\begin{commentary}
If an interrupt occurs between the execution of an NTLH instruction and its
subsequent memory-access instruction, execution will normally resume at the
memory-access instruction.
That the NTLH instruction is not reexecuted does not change the semantics of
the program.
\end{commentary}
